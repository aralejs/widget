{"title":"Widget","meta":{"title":"Widget","filepath":"README.md","filename":"index","directory":"","id":"-readme","template":"post","category":"docs"},"body":"\n[![Build Status](https://travis-ci.org/aralejs/widget.png)](https://travis-ci.org/aralejs/widget)\n\n\nWidget 是 UI 组件的基础类，约定了组件的基本生命周期，实现了一些通用功能。基于 Widget\n可以构建出任何你想要的 Web 界面组件。\n\n----------\n\n**注**：Handlebars 依赖仅在混入 `Templatable` 后才产生。\n\n\n## 使用说明\n\n\n### extend `Widget.extend(properties)`\n\n使用 `extend` 方法，可以基于 `Widget` 来创建子类。\n\n```js\ndefine(function(require, exports, module) {\n    var Widget = require('widget');\n\n    // 定义 SimpleTabView 类\n    var SimpleTabView = Widget.extend({\n        events: {\n            'click .nav li': 'switchTo'\n        },\n        switchTo: function(index) {\n            ...\n        },\n        ...\n    });\n\n    // 实例化\n    var demo = new SimpleTabView({ element: '#demo' }).render();\n});\n\n```\n\n详细示例请访问：[simple-tabview.html](http://aralejs.org/widget/examples/simple-tabview.html)\n\n\n### initialize `new Widget([config])`\n\nWidget 实例化时，会调用此方法。\n\n```js\nvar widget = new Widget({\n   element: '#demo',\n   className: 'widget',\n   model: {\n       title: '设计原则',\n       content: '开放、简单、易用'\n   }\n});\n```\n\n`config` 参数用来传入选项，实例化后可以通过 `get/set` 访问。`config`\n参数如果包含 `element` 和 `model` 属性，实例化后会直接放到 `this` 上，即可通过\n`this.element`、`this.model` 来获取。\n\n\n在 `initialize` 方法中，确定了组件构建的基本流程：\n\n```js\n// 初始化 attrs\nthis.initAttrs(config, dataAttrsConfig);\n\n// 初始化 props\nthis.parseElement();\nthis.initProps();\n\n// 初始化 events\nthis.delegateEvents();\n\n// 子类自定义的初始化\nthis.setup();\n```\n\n下面逐一讲述。\n\n\n### initAttrs `widget.initAttrs(config, [dataAttrsConfig])`\n\n属性的初始化方法。通过该方法，会将用户传入的配置与所继承的默认属性进行合并，并进行初始化操作。\n\n子类如果想在 `initAttrs` 执行之前或之后进行一些额外处理，可以覆盖该方法：\n\n```js\nvar MyWidget = Widget.extend({\n    initAttrs: function(config) {\n        // 提前做点处理\n\n        // 调用父类的\n        MyWidget.superclass.initAttrs.call(this, config);\n\n        // 之后做点处理\n    }\n});\n\n```\n\n**注意**：一般情况下不需要覆盖 `initAttrs`。\n\n\n### parseElement `widget.parseElement()`\n\n该方法只干一件事：根据配置信息，构建好 `this.element`。\n\n默认情况下，如果 `config` 参数中传入了 `element` 属性（取值可为 DOM element / selector），\n会直接根据该属性来获取 `this.element` 对象。\n\n`this.element` 是一个 jQuery / Zepto 对象。\n\n\n### parseElementFromTemplate `widget.parseElementFromTemplate()`\n\n如果 `config` 参数中未传入 `element` 属性，则会根据 `template` 属性来构建\n`this.element`。 默认的 `template` 是 `<div></div>`。\n\n子类可覆盖该方法，以支持 Handlebars、Mustache 等模板引擎。\n\n\n### element `widget.element`\n\nwidget 实例对应的 DOM 根节点，是一个 jQuery / Zepto 对象。\n\n\n### initProps `widget.initProps()`\n\nproperties 的初始化方法，提供给子类覆盖，比如：\n\n```js\ninitProps: function() {\n    this.targetElement = $(this.get('target'));\n}\n```\n\n\n### delegateEvents `widget.delegateEvents([events])`\n\n### delegateEvents `widget.delegateEvents(eventType, handler)`\n\n注册事件代理。在 Widget 组件的设计里，推荐使用代理的方式来注册事件。这样可以使得对应的\nDOM 内容有修改时，无需重新绑定。\n\n`widget.delegateEvents()` 会在实例初始化时自动调用，这时会从 `this.events` 中取得声明的代理事件，比如\n\n```js\nvar MyWidget = Widget.extend({\n    events: {\n        \"dblclick\": \"open\",\n        \"click .icon.doc\": \"select\",\n        \"mouseover .date\": \"showTooltip\"\n    },\n    open: function() {\n        ...\n    },\n    select: function() {\n        ...\n    },\n    ...\n});\n```\n\n`events` 中每一项的格式是：`\"event selector\": \"callback\"`，当省略 `selector`\n时，默认会将事件绑定到 `this.element` 上。`callback` 可以是字符串，表示当前实例上的方法名；\n也可以直接传入函数。\n\n`events` 还可以是方法，返回一个 events hash 对象即可。比如\n\n```js\nvar MyWidget = Widget.extend({\n    events: function() {\n        var hash = {\n            \"click\": \"open\",\n            \"click .close\": \"close\"\n        };\n\n        return hash;\n    },\n    ...\n});\n```\n\n`events` 中，还支持 `{{name}}` 表达式，比如上面的代码，可以简化为：\n\n```js\nvar MyWidget = Widget.extend({\n    events: {\n        \"click\": \"open\",\n        \"click .close\": \"close\",\n        \"mouseover {{attrs.trigger}}\": \"open\",\n        \"mouseover {{attrs.panels}}\": \"hover\"\n    },\n    ...\n});\n```\n\n实例化后，还可以通过 `delegateEvents` 方法动态添加事件代理：\n\n```js\nvar myWidget = new Widget();\n\nmyWidget.delegateEvents('click .move', function() {\n  // ...\n});\n```\n\n\n### undelegateEvents `widget.undelegateEvents([eventType])`\n\n卸载事件代理。不带参数时，表示卸载所有事件。\n\n\n### setup `widget.setup()`\n\n提供给子类覆盖的初始化方法。可以在此处理更多初始化信息，比如\n\n```js\nvar TabView = Widget.extend({\n    ...\n    setup: function() {\n        this.activeIndex = getActiveIndex();\n    },\n    ...\n});\n```\n\n\n### render `widget.render()`\n\n提供给子类覆盖的初始化方法。render 方法只干一件事件：将 `this.element` 渲染到页面上。\n\n默认无需覆盖。需要覆盖时，请使用 `return this` 来保持该方法的链式约定。\n\n\n### $ `widget.$(selector)`\n\n在 `this.element` 内查找匹配节点。\n\n\n### destroy `widget.destroy()`\n\n销毁实例。\n\n\n### on `widget.on(event, callback, [context])`\n\n这是从 Events 中自动混入进来的方法。还包括 `off` 和 `trigger`。\n\n具体使用请参考 [events 使用文档](http://aralejs.org/events/)。\n\n\n### autoRenderAll `Widget.autoRenderAll([root], [callback])`\n\n根据 data-widget 属性，自动渲染找到的所有 Widget 类组件。\n\n\n### query `Widget.query(selector)`\n\n查询与 selector 匹配的第一个 DOM 节点，得到与该 DOM 节点相关联的 Widget 实例。\n\n\n## Templatable\n\n可混入的功能类，提供 Handlebars 模板支持。\n\n```js\nvar Templatable = require('widget-templatable');\n\nvar MyWidget = Widget.extend({\n    Implements: Templatable\n});\n\nvar myWidget = new MyWidget({\n    template: '<h3>{{title}}</h3><ol>{{#each list}}<li>{{item}}</li>{{/each}}',\n    model: {\n        'title': '标题',\n        'list': [\n            { 'item': '文章一' },\n            { 'item': '文章二' }\n        ]\n    },\n    parentNode: '#demo'\n});\n\nmyWidget.render();\n```\n\n\n### renderPartial `widget.renderPartial(selector)`\n\n局部渲染。根据传入的 `selector` 参数，刷新匹配的区域。\n\n默认无需覆盖。需要覆盖时，请使用 `return this` 来保持该方法的链式约定。\n\n","abspath":"D:/workspace/demo/widget/README.md","filepath":"README.md","filename":"index","directory":"","id":"-readme","tags":[],"status":"public","html":"<p><a href=\"https://travis-ci.org/aralejs/widget\"><img src=\"https://travis-ci.org/aralejs/widget.png\" alt=\"Build Status\"></a></p>\n<p>Widget 是 UI 组件的基础类，约定了组件的基本生命周期，实现了一些通用功能。基于 Widget\n可以构建出任何你想要的 Web 界面组件。</p>\n<hr>\n<p><strong>注</strong>：Handlebars 依赖仅在混入 <code>Templatable</code> 后才产生。</p>\n<h2 id=\"使用说明\">使用说明</h2><h3 id=\"extend-widget-extend-properties\">extend <code>Widget.extend(properties)</code></h3><p>使用 <code>extend</code> 方法，可以基于 <code>Widget</code> 来创建子类。</p>\n<div class=\"highlight\"><pre><code class=\"javascript\">define(<span class=\"keyword\">function</span>(require, exports, module) {\n    <span class=\"keyword\">var</span> Widget = require(<span class=\"string\">'widget'</span>);\n\n    <span class=\"comment\">// 定义 SimpleTabView 类</span>\n    <span class=\"keyword\">var</span> SimpleTabView = Widget.extend({\n        events: {\n            <span class=\"string\">'click .nav li'</span>: <span class=\"string\">'switchTo'</span>\n        },\n        switchTo: <span class=\"keyword\">function</span>(index) {\n            ...\n        },\n        ...\n    });\n\n    <span class=\"comment\">// 实例化</span>\n    <span class=\"keyword\">var</span> demo = <span class=\"keyword\">new</span> SimpleTabView({ element: <span class=\"string\">'#demo'</span> }).render();\n});</code></pre></div><p>详细示例请访问：<a href=\"http://aralejs.org/widget/examples/simple-tabview.html\">simple-tabview.html</a></p>\n<h3 id=\"initialize-new-widget-config\">initialize <code>new Widget([config])</code></h3><p>Widget 实例化时，会调用此方法。</p>\n<div class=\"highlight\"><pre><code class=\"javascript\"><span class=\"keyword\">var</span> widget = <span class=\"keyword\">new</span> Widget({\n   element: <span class=\"string\">'#demo'</span>,\n   className: <span class=\"string\">'widget'</span>,\n   model: {\n       title: <span class=\"string\">'设计原则'</span>,\n       content: <span class=\"string\">'开放、简单、易用'</span>\n   }\n});</code></pre></div><p><code>config</code> 参数用来传入选项，实例化后可以通过 <code>get/set</code> 访问。<code>config</code>\n参数如果包含 <code>element</code> 和 <code>model</code> 属性，实例化后会直接放到 <code>this</code> 上，即可通过\n<code>this.element</code>、<code>this.model</code> 来获取。</p>\n<p>在 <code>initialize</code> 方法中，确定了组件构建的基本流程：</p>\n<div class=\"highlight\"><pre><code class=\"javascript\"><span class=\"comment\">// 初始化 attrs</span>\n<span class=\"keyword\">this</span>.initAttrs(config, dataAttrsConfig);\n\n<span class=\"comment\">// 初始化 props</span>\n<span class=\"keyword\">this</span>.parseElement();\n<span class=\"keyword\">this</span>.initProps();\n\n<span class=\"comment\">// 初始化 events</span>\n<span class=\"keyword\">this</span>.delegateEvents();\n\n<span class=\"comment\">// 子类自定义的初始化</span>\n<span class=\"keyword\">this</span>.setup();</code></pre></div><p>下面逐一讲述。</p>\n<h3 id=\"initattrs-widget-initattrs-config-dataattrsconfig\">initAttrs <code>widget.initAttrs(config, [dataAttrsConfig])</code></h3><p>属性的初始化方法。通过该方法，会将用户传入的配置与所继承的默认属性进行合并，并进行初始化操作。</p>\n<p>子类如果想在 <code>initAttrs</code> 执行之前或之后进行一些额外处理，可以覆盖该方法：</p>\n<div class=\"highlight\"><pre><code class=\"javascript\"><span class=\"keyword\">var</span> MyWidget = Widget.extend({\n    initAttrs: <span class=\"keyword\">function</span>(config) {\n        <span class=\"comment\">// 提前做点处理</span>\n\n        <span class=\"comment\">// 调用父类的</span>\n        MyWidget.superclass.initAttrs.call(<span class=\"keyword\">this</span>, config);\n\n        <span class=\"comment\">// 之后做点处理</span>\n    }\n});</code></pre></div><p><strong>注意</strong>：一般情况下不需要覆盖 <code>initAttrs</code>。</p>\n<h3 id=\"parseelement-widget-parseelement\">parseElement <code>widget.parseElement()</code></h3><p>该方法只干一件事：根据配置信息，构建好 <code>this.element</code>。</p>\n<p>默认情况下，如果 <code>config</code> 参数中传入了 <code>element</code> 属性（取值可为 DOM element / selector），\n会直接根据该属性来获取 <code>this.element</code> 对象。</p>\n<p><code>this.element</code> 是一个 jQuery / Zepto 对象。</p>\n<h3 id=\"parseelementfromtemplate-widget-parseelementfromtemplate\">parseElementFromTemplate <code>widget.parseElementFromTemplate()</code></h3><p>如果 <code>config</code> 参数中未传入 <code>element</code> 属性，则会根据 <code>template</code> 属性来构建\n<code>this.element</code>。 默认的 <code>template</code> 是 <code>&lt;div&gt;&lt;/div&gt;</code>。</p>\n<p>子类可覆盖该方法，以支持 Handlebars、Mustache 等模板引擎。</p>\n<h3 id=\"element-widget-element\">element <code>widget.element</code></h3><p>widget 实例对应的 DOM 根节点，是一个 jQuery / Zepto 对象。</p>\n<h3 id=\"initprops-widget-initprops\">initProps <code>widget.initProps()</code></h3><p>properties 的初始化方法，提供给子类覆盖，比如：</p>\n<div class=\"highlight\"><pre><code class=\"javascript\">initProps: <span class=\"keyword\">function</span>() {\n    <span class=\"keyword\">this</span>.targetElement = $(<span class=\"keyword\">this</span>.get(<span class=\"string\">'target'</span>));\n}</code></pre></div><h3 id=\"delegateevents-widget-delegateevents-events\">delegateEvents <code>widget.delegateEvents([events])</code></h3><h3 id=\"delegateevents-widget-delegateevents-eventtype-handler\">delegateEvents <code>widget.delegateEvents(eventType, handler)</code></h3><p>注册事件代理。在 Widget 组件的设计里，推荐使用代理的方式来注册事件。这样可以使得对应的\nDOM 内容有修改时，无需重新绑定。</p>\n<p><code>widget.delegateEvents()</code> 会在实例初始化时自动调用，这时会从 <code>this.events</code> 中取得声明的代理事件，比如</p>\n<div class=\"highlight\"><pre><code class=\"javascript\"><span class=\"keyword\">var</span> MyWidget = Widget.extend({\n    events: {\n        <span class=\"string\">\"dblclick\"</span>: <span class=\"string\">\"open\"</span>,\n        <span class=\"string\">\"click .icon.doc\"</span>: <span class=\"string\">\"select\"</span>,\n        <span class=\"string\">\"mouseover .date\"</span>: <span class=\"string\">\"showTooltip\"</span>\n    },\n    open: <span class=\"keyword\">function</span>() {\n        ...\n    },\n    select: <span class=\"keyword\">function</span>() {\n        ...\n    },\n    ...\n});</code></pre></div><p><code>events</code> 中每一项的格式是：<code>&quot;event selector&quot;: &quot;callback&quot;</code>，当省略 <code>selector</code>\n时，默认会将事件绑定到 <code>this.element</code> 上。<code>callback</code> 可以是字符串，表示当前实例上的方法名；\n也可以直接传入函数。</p>\n<p><code>events</code> 还可以是方法，返回一个 events hash 对象即可。比如</p>\n<div class=\"highlight\"><pre><code class=\"javascript\"><span class=\"keyword\">var</span> MyWidget = Widget.extend({\n    events: <span class=\"keyword\">function</span>() {\n        <span class=\"keyword\">var</span> hash = {\n            <span class=\"string\">\"click\"</span>: <span class=\"string\">\"open\"</span>,\n            <span class=\"string\">\"click .close\"</span>: <span class=\"string\">\"close\"</span>\n        };\n\n        <span class=\"keyword\">return</span> hash;\n    },\n    ...\n});</code></pre></div><p><code>events</code> 中，还支持 <code>{{name}}</code> 表达式，比如上面的代码，可以简化为：</p>\n<div class=\"highlight\"><pre><code class=\"javascript\"><span class=\"keyword\">var</span> MyWidget = Widget.extend({\n    events: {\n        <span class=\"string\">\"click\"</span>: <span class=\"string\">\"open\"</span>,\n        <span class=\"string\">\"click .close\"</span>: <span class=\"string\">\"close\"</span>,\n        <span class=\"string\">\"mouseover {{attrs.trigger}}\"</span>: <span class=\"string\">\"open\"</span>,\n        <span class=\"string\">\"mouseover {{attrs.panels}}\"</span>: <span class=\"string\">\"hover\"</span>\n    },\n    ...\n});</code></pre></div><p>实例化后，还可以通过 <code>delegateEvents</code> 方法动态添加事件代理：</p>\n<div class=\"highlight\"><pre><code class=\"javascript\"><span class=\"keyword\">var</span> myWidget = <span class=\"keyword\">new</span> Widget();\n\nmyWidget.delegateEvents(<span class=\"string\">'click .move'</span>, <span class=\"keyword\">function</span>() {\n  <span class=\"comment\">// ...</span>\n});</code></pre></div><h3 id=\"undelegateevents-widget-undelegateevents-eventtype\">undelegateEvents <code>widget.undelegateEvents([eventType])</code></h3><p>卸载事件代理。不带参数时，表示卸载所有事件。</p>\n<h3 id=\"setup-widget-setup\">setup <code>widget.setup()</code></h3><p>提供给子类覆盖的初始化方法。可以在此处理更多初始化信息，比如</p>\n<div class=\"highlight\"><pre><code class=\"javascript\"><span class=\"keyword\">var</span> TabView = Widget.extend({\n    ...\n    setup: <span class=\"keyword\">function</span>() {\n        <span class=\"keyword\">this</span>.activeIndex = getActiveIndex();\n    },\n    ...\n});</code></pre></div><h3 id=\"render-widget-render\">render <code>widget.render()</code></h3><p>提供给子类覆盖的初始化方法。render 方法只干一件事件：将 <code>this.element</code> 渲染到页面上。</p>\n<p>默认无需覆盖。需要覆盖时，请使用 <code>return this</code> 来保持该方法的链式约定。</p>\n<h3 id=\"widget-selector\">$ <code>widget.$(selector)</code></h3><p>在 <code>this.element</code> 内查找匹配节点。</p>\n<h3 id=\"destroy-widget-destroy\">destroy <code>widget.destroy()</code></h3><p>销毁实例。</p>\n<h3 id=\"on-widget-on-event-callback-context\">on <code>widget.on(event, callback, [context])</code></h3><p>这是从 Events 中自动混入进来的方法。还包括 <code>off</code> 和 <code>trigger</code>。</p>\n<p>具体使用请参考 <a href=\"http://aralejs.org/events/\">events 使用文档</a>。</p>\n<h3 id=\"autorenderall-widget-autorenderall-root-callback\">autoRenderAll <code>Widget.autoRenderAll([root], [callback])</code></h3><p>根据 data-widget 属性，自动渲染找到的所有 Widget 类组件。</p>\n<h3 id=\"query-widget-query-selector\">query <code>Widget.query(selector)</code></h3><p>查询与 selector 匹配的第一个 DOM 节点，得到与该 DOM 节点相关联的 Widget 实例。</p>\n<h2 id=\"templatable\">Templatable</h2><p>可混入的功能类，提供 Handlebars 模板支持。</p>\n<div class=\"highlight\"><pre><code class=\"javascript\"><span class=\"keyword\">var</span> Templatable = require(<span class=\"string\">'widget-templatable'</span>);\n\n<span class=\"keyword\">var</span> MyWidget = Widget.extend({\n    Implements: Templatable\n});\n\n<span class=\"keyword\">var</span> myWidget = <span class=\"keyword\">new</span> MyWidget({\n    template: <span class=\"string\">'&lt;h3&gt;{{title}}&lt;/h3&gt;&lt;ol&gt;{{#each list}}&lt;li&gt;{{item}}&lt;/li&gt;{{/each}}'</span>,\n    model: {\n        <span class=\"string\">'title'</span>: <span class=\"string\">'标题'</span>,\n        <span class=\"string\">'list'</span>: [\n            { <span class=\"string\">'item'</span>: <span class=\"string\">'文章一'</span> },\n            { <span class=\"string\">'item'</span>: <span class=\"string\">'文章二'</span> }\n        ]\n    },\n    parentNode: <span class=\"string\">'#demo'</span>\n});\n\nmyWidget.render();</code></pre></div><h3 id=\"renderpartial-widget-renderpartial-selector\">renderPartial <code>widget.renderPartial(selector)</code></h3><p>局部渲染。根据传入的 <code>selector</code> 参数，刷新匹配的区域。</p>\n<p>默认无需覆盖。需要覆盖时，请使用 <code>return this</code> 来保持该方法的链式约定。</p>\n","toc":"<ul><li><a href=\"#使用说明\">使用说明</a><ul><li><a href=\"#extend-widget-extend-properties\">extend <code>Widget.extend(properties)</code></a></li><li><a href=\"#initialize-new-widget-config\">initialize <code>new Widget([config])</code></a></li><li><a href=\"#initattrs-widget-initattrs-config-dataattrsconfig\">initAttrs <code>widget.initAttrs(config, [dataAttrsConfig])</code></a></li><li><a href=\"#parseelement-widget-parseelement\">parseElement <code>widget.parseElement()</code></a></li><li><a href=\"#parseelementfromtemplate-widget-parseelementfromtemplate\">parseElementFromTemplate <code>widget.parseElementFromTemplate()</code></a></li><li><a href=\"#element-widget-element\">element <code>widget.element</code></a></li><li><a href=\"#initprops-widget-initprops\">initProps <code>widget.initProps()</code></a></li><li><a href=\"#delegateevents-widget-delegateevents-events\">delegateEvents <code>widget.delegateEvents([events])</code></a></li><li><a href=\"#delegateevents-widget-delegateevents-eventtype-handler\">delegateEvents <code>widget.delegateEvents(eventType, handler)</code></a></li><li><a href=\"#undelegateevents-widget-undelegateevents-eventtype\">undelegateEvents <code>widget.undelegateEvents([eventType])</code></a></li><li><a href=\"#setup-widget-setup\">setup <code>widget.setup()</code></a></li><li><a href=\"#render-widget-render\">render <code>widget.render()</code></a></li><li><a href=\"#widget-selector\">$ <code>widget.$(selector)</code></a></li><li><a href=\"#destroy-widget-destroy\">destroy <code>widget.destroy()</code></a></li><li><a href=\"#on-widget-on-event-callback-context\">on <code>widget.on(event, callback, [context])</code></a></li><li><a href=\"#autorenderall-widget-autorenderall-root-callback\">autoRenderAll <code>Widget.autoRenderAll([root], [callback])</code></a></li><li><a href=\"#query-widget-query-selector\">query <code>Widget.query(selector)</code></a></li></ul></li><li><a href=\"#templatable\">Templatable</a><ul><li><a href=\"#renderpartial-widget-renderpartial-selector\">renderPartial <code>widget.renderPartial(selector)</code></a></li></ul></ul>","iframes":{},"template":"post"}